jvm垃圾回收
	遵循分代回收算法分为新生代和年老代.
	在新生代为了防止内存碎片问题,垃圾会收取采用复制算法,因此新生代
	分为Eden,surivor1和survior2,内存占比8:1:1
	创建对象时,首先在Eden中创建,如果Eden已满,则在survior1中分配,
	如果Eden和survior1内存太少,会启用分配担保,就其中对象转移到老年代中;
	新对象创建在Eden中.'分配担保'只发生在新生代中.
	
	创建的大对象直接进入年老代,大对象(连续占用大量内存的对象如数组,大对象的大小可以通过参数设置),
	
	生命周期较长的对象进入年老代:判断生命周期,每个对象都有一个计数器,新生代进行垃圾回收时,如果未被回收,
	年龄就会加1,当年龄超过一定值时,该对象就会被转移到老年代中.(最大值也可以通过参数设置)
	
	相同年龄的对象内存超过survior一半的对象,这些对象和年龄超过这些的对象被转移到老年代中.
	
	
	分配担保:新生代进行一次垃圾回收时,首先会检查老年代中连续的空闲区域是否大于新生代所有对象的大小,
	如果成立,此时进行回收时没有任何风险.
	如果不成立,此时垃圾回收器就会进行一次预测,根据以往的回收数,预测这次回收的回收数, 预测数如果小于
	老年代的空间,就进行垃圾回收,如果大于,会对老年代先进行回收,扩展空间,为新生代进行担保.
	
	新生代使用'复制'算法实现垃圾回收,
	老年代使用'标记-清除','标记-整理'实现垃圾回收,
	只有复制的算法需要分配担保.
	
	回收jvm中的五大区域:
		程序计数器,java虚拟机栈,本地方法栈,堆,方法区
		
		程序计数器,java虚拟机栈和本地方法栈是线程私有的,随线程的创建而创建,回收的时机确定
		
		堆和方法区: 在虚拟机启动时创建,在停止时释放.
		
		回收对象:判断无效对象,
		引用计数法(无法解决循环引用的问题):每引用一次,计数器加一,引用失效,计数器减一,计数器为0时,对象为无效对象.
		可达性分析法:所有跟GC Roots有关联的对象都是有效对象
		
		GC Roots: 包含虚拟机栈引用的对象,方法区中静态属性引用的对象,常量引用的对象,

	回收过程:筛选出无效对象后,不是立即清除,而是,给一次重生的机会,
	
			判断该对象是否覆盖了finalize()方法,
				覆盖并且没有执行,将方法扔到F-Queue队列中;
				未覆盖,直接释放对象内存,
				
				执行F-queue队列的方法:低优先级执行,不保证全部执行方法.如果此方法耗时过长,会直接停止,对象清除
				
				对象死亡或者重生,执行方法时,将this赋值给某个引用,对象就重生,否则就会被清除.不建议使用
				适应try-finally
				
		方法区的回收:存储的主要是生命周期较长的类信息,常量静态变量,,方法区类似于方法区中的老年代,每次回收只有
			少量的垃圾被清除.
				主要清除废弃常量,废弃类.
				常量和对象相依,只要不被引用,就认为是废弃常量,会被清除 
				废弃类比较复杂,首先其中的对象没有任何引用,class文件在类被删除时清除.

垃圾回收算法:标记清除算法 ,标记需清除数据,然后清除标记的,效率低存在大量碎片,降低空间利用率.

复制算法:	复制数据到一块上,	标记后,将有用的复制到另一块上,清除此快的所有内存. 缩小了内存,效率不高.(811解决)

标记整理算法: 	不直接清除,先是对象向边界移动,清除掉边界以外的内存,耗用时间长,解决了碎片占用问题

分代收集算法: 新生代和年老代的区分

专业词汇:

		Minor GC ,Major GC  ,Full GC

			Minor GC:从新生代回收内存,(大部分Eden区的内容都可以认为是垃圾)
			Major GC: 清理年老代,
			Full GC :清理整个堆空间,包括新生代和年老代
			




		
				
				
				
		
				
				
				
			
		
		
	
	
	
	
	

	
